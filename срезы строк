# Срезы строк—
# Основы Python
# Когда мы работаем со строками в программировании, из них регулярно приходится извлекать некую часть. Например, нам нужно выяснить, присутствует ли меньшая строка внутри большей. В этом уроке мы разберемся, как это сделать.

# Подстрока и срезы для строк
# Подстрока — это некоторая часть строки, которую нужно найти и извлечь.

# Представим, что у нас есть дата в таком формате: 12-08-2034. Нам нужно извлечь из нее подстроку, в которую входит только год.

# Если подумать логически, то нужно посчитать индекс символа, с которого начинается год, и затем извлечь четыре символа. Индексы в строке начинаются с нуля, значит, первый символ года доступен по индексу 6, а последний символ — по индексу 9. Проверим:

value = '12-08-2034'

print(value[6])  # => 2
print(value[9])  # => 4
# Зная эти индексы, мы можем воспользоваться срезами и получить нужную подстроку:

value = '12-08-2034'

year = value[6:10]
print(year)  # => 2034
# Срезы для строк в Python — это механизм, с помощью которого извлекается подстрока по указанным параметрам. В примере выше мы взяли подстроку с 6 индекса по 10 индекс, не включая, то есть с 6 по 9 включительно. Формула выглядит так:

# str[начальный индекс:конечный индекс]

# Пара примеров
value = '01-12-9873'

# Срез строки это всегда строка,
# даже если внутри строки было число.
value[1:2]  # '1'
value[3:5]  # '12'
# Срезы — механизм с большим количеством вариаций. 
# Например, если не указать вторую границу, то извлечение произойдет до конца строки. То же самое с первой границей — началом строки:

value = 'Hexlet'
value[3:]  # 'let'
value[:3]  # 'Hex'
# Можно указать даже отрицательные индексы. 
# В таком случае отсчет идет с обратной стороны:

value = 'Hexlet'
# Правая граница отрицательная. Считаем -1 от конца строки
value[3:-1]  # 'le'
# Левая граница отрицательная. Считаем -5 от конца строки
value[-5:3]  # 'ex'
# У срезов два обязательных параметра, но иногда используется и третий.

# Шаг извлечения
# У срезов есть третий необязательный параметр — шаг извлечения. 
# По умолчанию он равен единице, но мы можем его изменить:

value = 'Hexlet'
value[1:5:2]  # el
# 1:5 это 'exle'
# шаг 2 это каждый второй, то есть 'e' и 'l'

# Если используется отрицательный шаг, и элементы среза извлекаются в обратном порядке — тогда и границы среза тоже нужно указывать в обратном порядке.
#  Первой указывается правая граница среза, второй — левая:

value = 'Hexlet'
# Символ с индексом 1 не будет включен в подстроку
value[4:1:-1]  # 'elx'
# Срезы можно указывать не только через числа, но и с использованием переменных:

value = 'Hexlet'
start = 1
end = 5
value[start:end]  # 'exle'




def normalize_url(adres):
    if adres[0:8] =='https://':
       return adres
    elif adres[0:7]=='http://' in adres:
        modadres= adres[7:] 
        print(modadres) 
        adres= 'https://'+modadres
        return adres
    else:
        adres= 'https://'+adres
        return adres    


print(normalize_url('http://ya.ru'))




def join_strs(strs):
    result = ''
    for s in strs:
         result += ' ' + s  # а вот и плюс
    return result[1:]


    def join_strs_better(strs):
        return ' '.join(strs)

join_strs_better(strings)


s1= 'привет страна далекая'
s2=',ehfnbyj'
a=s1+s2
b= list(a)
print(b)

print(''.join([s1, s2]))



def join_strs_better(strs):

    return ''.join(strs)


fin = join_strs_better(b) 
print(fin)    



# r.isdigit()  проверяет строк на цифру 
 